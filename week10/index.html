<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WDD-330 | Portfolio</title>
    <meta name="description" content="Portfolio to keep track and record of all the weekly activities of the semester">

    
    <link rel="stylesheet" href="css/normalize.css">
    <link rel="stylesheet" href="css/small.css">
    <link rel="stylesheet" href="css/medium.css">
</head>
<body>

    <header>
        <h1>Portfolio - Week 10</h1>
    </header>

    <main>        
        <h2>Questions</h2>
        <hr>
        <ul>
            <li>Since Built-in form validation is not supported by all browsers, is it better to use JavaScript to validate forms?</li>
            <li>Are there any possible errors when using the Contraining Validation API?</li>
            <li>Is it better to use Constraining Validation API or pure javascript to validate a form?</li>
            <li>In which contexts is it more advisable to use each form validation method?</li>
            <li>What is the use of the init object that can be passed as a parameter in the fetch() method?</li>
            <li>Why is it important to use headers?</li>
        </ul>

        <h2>Notes</h2>
        <hr>
        <ul>
            <li>Client-side form validation is the method we use to verify that all the data in a form is in the correct format, before sending it to the server.</li>
            <li>Client-side form validation is more for a good user experience than for security, since the real security is done on the server.</li>
            <li>There are two different types of client-side validation: Built-in form validation which uses HTML5 form validation features and JavaScript validation which uses JavaScript code to validate, it is more customizable but we have to write all the code.</li>
            <li>Built-in form validation uses validation attributes on form elements.</li>
            <li>Regular expression is a very powerful resource to validate form fields. It is necessary to know well all the patterns to be able to take advantage of this functionality.</li>
            <li>You must use JavaScript if you want to take control over the look and feel of native error messages or to deal with legacy browsers that do not support HTML's built-in form validation.</li>
            <li>The Constraint Validation API consists of a set of methods and properties available in various form element DOM interfaces, and which can be used by Javascript to validate a form.</li>
            <li>In some cases it is better to use pure Javascript, such as legacy browser support or custom controls, you won't be able to or won't want to use the Constraint Validation API.</li>
            <li>In order to reduce the user's frustration, it's very important to provide as much helpful information as possible in order to guide them in correcting their inputs.</li>
            <li>In order to help your users correct the data they provide. Display explicit error messages, be permissive about the input format, point out exactly where the error occurs, especially on large forms.</li>
            <li>The Fetch API provides a JavaScript interface for accessing and manipulating parts of the HTTP pipeline, such as requests and responses. It also provides a global fetch() method that provides an easy, logical way to fetch resources asynchronously across the network.</li>
            <li>The fetch() method can optionally accept a second parameter, an init object that allows you to control a number of different settings.</li>
            <li>For supplying your own request object, instead of passing a path to the resource you want to request into the fetch() call, you can create a request object using the Request() constructor, and pass that in as a fetch() method argument.</li>
            <li>The Headers interface allows you to create your own headers object via the Headers() constructor. A headers object is a simple multi-map of names to values.</li>
            <li>A good use case for headers is checking whether the content type is correct before you process it further.</li>
            <li>Since headers can be sent in requests and received in responses, and have various limitations about what information can and should be mutable, headers objects have a guard property. It affects which mutation operations are allowed on the headers object.</li>
            <li>Response instances are returned when fetch() promises are resolved.</li>
            <li>The Response() constructor takes two optional arguments â€” a body for the response, and an init object.</li>
            <li>Fetch API support can be detected by checking for the existence of Headers, Request, Response or fetch() on the Window or Worker scope.</li>           
        </ul>

        <h2>Exercises</h2>
        <hr>
        <ul>
            <li><a href="exercices/builtInFormValidation.html">Built-in Form Validation Example</a></li>           
            <li><a href="exercices/constrainingValidationApi.html">Constraining Validation API Usage Example</a></li>    
            <li><a href="exercices/pureJavascriptValidationForm.html">Pure JavaScript Form Validation Example</a></li>  
            <li><a href="exercices/supplying_request_options.html">Supplying Request Options Examples</a></li>           
        </ul>

    </main>

    
    <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
    <script>WebFont.load({google: {families: ['Lato']}});</script>

</body>
</html>
